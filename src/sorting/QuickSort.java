package sorting;

/**
 * 快速排序
 * 
 * 快速排序是由分治法策略，它的基本思想是：选择一个基准数，通过一趟排序将
 * 要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所
 * 有数据都要小；然后，在按此方法对这两部分数据分别进行同样的操作，整个排
 * 序过程可以递归进行，以此达到整个数据编程有序序列。
 * 
 * 快速排序流程：
 * 1、从数列中挑出一个基准值；
 * 2、将所有比基准值小的摆放在基准值前面，所有比基准值大的摆放在基准值后面
 * 		（相同的数可以到任一边）；在这个操作之后，则基准值就位于数列中间位置
 * 		也即：基准值前面的子数列 <  基准值  <  基准值后面的子数列；
 * 3、递归地把“基准值前面的子数列”和“基准值后面的子数列”分别按上面同样
 * 		的操作进行排序处理；
 * 
 * 快速排序的时间复杂度：
 * 		在最坏情况下是O(N^2)，平均情况下是O(N*lgN)；
 * 
 * 对上面的解释：假设被排序的数列中有N个数，那么遍历一次的时间复杂度是O(N),
 * 需要遍历多少次呢？因为快速排序时采用的分治法进行遍历的，可以将其看作一棵
 * 二叉树，它需要遍历的次数就是二叉树的深度；而根据完全二叉树的定义，它的
 * 深度至少是lg(N+1)，因此快速排序的遍历次数至少是lg(N+1)次；而一棵二叉树的
 * 最大深度就是N，因此快速排序的遍历次数最多是N次；因而有上面的时间复杂度.
 * 
 * 快速排序是不稳定的算法，不满足稳定性算法的定义；
 * 
 * @author Stargazer
 * @date 2017-03-16
 */
public class QuickSort {

	/**
	 * 快速排序
	 * @param a 		待排序的数组
	 * @param left		数组的左边界（例如，从起始位置开始排序，则left=0）
	 * @param right	数组的右边界（例如，排序截至到数组末尾，则right=a.length-1）
	 */
	public static void quickSort(int[] a, int left, int right){
		
		if(left < right){
			int i, j, x;
			
			i = left;
			j = right;
			x = a[i];				//作为基准值，i这个位置就相当于一个空圈了
			
			while(i < j){
				/*每次都是从最右边开始，从右往左找出第一个小于基准值x的数，并
				 * 把该数放到空圈位置中，
				 */
				while(i < j && a[j] > x)
					j--;			//从右向左找出第一个小于x的数
				if(i < j)
					a[i++] = a[j];
				
				/*经过上面的处理后，小于基准值x的数a[j]放到了原来的i位置上了，并把i
				 * 向后移动一位，此时便从i位置开始从左往右找出第一个大于基准值x
				 * 的数，并把该数放到之前已经取走数的j位置上，并让j向前移动一位。
				 */
				while(i < j && a[i] < x)
					i++;			//从左向右找出第一个大于x的数
				if(i < j)
					a[j--] = a[i];
			}
			/*经过上面的处理后，i位置左边的数就都比x小，i位置右边的数就都比x大，
			 * 所以此时就可以把基准值放回到i位置上了
			 */
			a[i] = x;
			
			quickSort(a, left, i-1);		//对小于基准值a[i]的(左边)子数列进行递归调用
			quickSort(a, i+1, right);	//对大于基准值a[i]的(右边)子数列进行递归调用
			
		}
	}
	
	
	public static void main(String[] args){
		int i;
		int[] A = {5, 3, 7, 9, 1, 4, 2, 6, 8};
		
		System.out.println("before sort:");
		for(i = 0; i < A.length; i++)
			System.out.print(A[i] + "\t");
		System.out.println("");
		
		quickSort(A, 0, A.length-1);
		
		System.out.println("after sort:");
		for(i = 0; i < A.length; i++)
			System.out.print(A[i] + "\t");
	}
}
